/*

   Copyright (c) 2011, The Chinese University of Hong Kong

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

	   http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

 */

#include <boost/thread/thread.hpp>
#include <boost/program_options.hpp>
#include <boost/random.hpp>
#include <boost/filesystem/operations.hpp>
#include <boost/ptr_container/ptr_vector.hpp>
#include <boost/process/context.hpp>
#include <boost/process/operations.hpp>
#include <boost/process/child.hpp>
#include "seed.hpp"
#include "file.hpp"
#include "tee.hpp"
#include "interact.hpp"

// Choose the appropriate Mersenne Twister engine for random number generation on 32-bit or 64-bit platform.
#if defined(__x86_64) || defined(__x86_64__) || defined(__amd64) || defined(__amd64__) || defined(_M_X64) || defined(_M_AMD64)
typedef boost::random::mt19937_64 mt19937eng;
#else
typedef boost::random::mt19937 mt19937eng;
#endif

int
main(int argc, char* argv[])
{
	std::cout << "igrow 1.0\n";

	using namespace igrow;
	path fragment_folder_path, initial_ligand_path, python_path, prepare_ligand4_path, docking_program_path, docking_config_path, output_folder_path, log_path, csv_path;
	size_t num_threads, seed, num_generations, num_elitists, num_mutants, num_children, max_atoms, max_hb_donors, max_hb_acceptors;
	fl max_mw, max_logp;
	bool idock;

	// Process program options.
	{
		using namespace std;
		using namespace boost::program_options;

		// Initialize the default values of optional arguments.
		const path default_output_folder_path = "output";
		const path default_log_path = "log.txt";
		const path default_csv_path = "log.csv";
		const unsigned int concurrency = boost::thread::hardware_concurrency();
		const unsigned int default_num_threads = concurrency ? concurrency : 1;
		const size_t default_seed = random_seed();
		const size_t default_num_generations = 8;
		const size_t default_num_mutants = 20;
		const size_t default_num_children = 20;
		const size_t default_num_elitists = 10;
		const size_t default_max_atoms = 80;
		const size_t default_max_hb_donors = 5;
		const size_t default_max_hb_acceptors = 10;
		const fl default_max_mw = 500;
		const fl default_max_logp = 5;

		options_description input_options("input (required)");
		input_options.add_options()
			("fragment_folder", value<path > (&fragment_folder_path)->required(), "path to folder of fragments in PDB format")
			("initial_ligand", value<path > (&initial_ligand_path)->required(), "path to initial ligand in PDB format")
			("python", value<path > (&python_path)->required(), "path to python executable")
			("prepare_ligand4", value<path > (&prepare_ligand4_path)->required(), "path to prepare_ligand4 script")
			("docking_program", value<path > (&docking_program_path)->required(), "path to idock or vina executable")
			("docking_config", value<path > (&docking_config_path)->required(), "path to idock or vina configuration file")
			;

		options_description output_options("output (optional)");
		output_options.add_options()
			("output_folder", value<path > (&output_folder_path)->default_value(default_output_folder_path), "folder of output results")
			("log", value<path > (&log_path)->default_value(default_log_path), "log file in plain text")
			("csv", value<path > (&csv_path)->default_value(default_csv_path), "log file in CSV format")
			;

		options_description miscellaneous_options("options (optional)");
		miscellaneous_options.add_options()
			("threads", value<size_t > (&num_threads)->default_value(default_num_threads), "number of worker threads to use")
			("seed", value<size_t > (&seed)->default_value(default_seed), "explicit non-negative random seed")
			("generations", value<size_t > (&num_generations)->default_value(default_num_generations), "number of GA generations")
			("elitists", value<size_t > (&num_elitists)->default_value(default_num_elitists), "number of elite ligands to carry over")
			("mutants", value<size_t > (&num_mutants)->default_value(default_num_mutants), "number of child ligands generated by mutation")
			("children", value<size_t > (&num_children)->default_value(default_num_children), "number of child ligands generated by crossover")
			("max_atoms", value<size_t > (&max_atoms)->default_value(default_max_atoms), "maximum number of atoms")
			("max_hb_donors", value<size_t > (&max_hb_donors)->default_value(default_max_hb_donors), "maximum number of hydrogen bond donors")
			("max_hb_acceptors", value<size_t > (&max_hb_acceptors)->default_value(default_max_hb_acceptors), "maximum number of hydrogen bond acceptors")
			("max_mw", value<fl > (&max_mw)->default_value(default_max_mw), "maximum molecular weight")
			("max_logp", value<fl > (&max_logp)->default_value(default_max_logp), "maximum logP")
			("config", value<path > (), "options can be loaded from a configuration file")
			;

		options_description all_options;
		all_options.add(input_options).add(output_options).add(miscellaneous_options);

		// If no command line argument is supplied, simply print the usage and exit.
		if (argc == 1)
		{
			cout << all_options;
			return 0;
		}

		// Parse command line arguments.
		try
		{
			variables_map vm;
			store(parse_command_line(argc, argv, all_options), vm);
			variable_value config_value = vm["config"];
			if (!config_value.empty()) // If a configuration file is presented, parse it.
			{
				ifile config_file(config_value.as<path > ());
				store(parse_config_file(config_file, all_options), vm);
			}
			vm.notify(); // Notify the user if there are any parsing errors.
		}
		catch (const exception& e)
		{
			cerr << e.what() << '\n';
			return 1;
		}

		// Validate fragment folder.
		if (!exists(fragment_folder_path))
		{
			cerr << "Fragment folder " << fragment_folder_path << " does not exist\n";
			return 1;
		}
		if (!is_directory(fragment_folder_path))
		{
			cerr << "Fragment folder " << fragment_folder_path << " is not a directory\n";
			return 1;
		}

		// Validate initial ligand.
		if (!exists(initial_ligand_path))
		{
			cerr << "Initial ligand " << initial_ligand_path << " does not exist\n";
			return 1;
		}
		if (!is_regular_file(initial_ligand_path))
		{
			cerr << "Initial ligand " << initial_ligand_path << " is not a regular file\n";
			return 1;
		}

		// Validate python executable.
		if (!exists(python_path))
		{
			cerr << "Python executable " << python_path << " does not exist\n";
			return 1;
		}
		if (!is_regular_file(python_path))
		{
			cerr << "Python executable " << python_path << " is not a regular file\n";
			return 1;
		}

		// Validate prepare_ligand4 python script.
		if (!exists(prepare_ligand4_path))
		{
			cerr << "prepare_ligand4 python script " << prepare_ligand4_path << " does not exist\n";
			return 1;
		}
		if (!is_regular_file(prepare_ligand4_path))
		{
			cerr << "prepare_ligand4 python script " << prepare_ligand4_path << " is not a regular file\n";
			return 1;
		}

		// Validate docking program.
		if (!exists(docking_program_path))
		{
			cerr << "Docking program " << docking_program_path << " does not exist\n";
			return 1;
		}
		if (!is_regular_file(docking_program_path))
		{
			cerr << "Docking program " << docking_program_path << " is not a regular file\n";
			return 1;
		}

		// Determine if the docking program is idock or vina.
		const string docking_program = docking_program_path.stem().string();
		if (docking_program == "idock")
		{
			idock = true;
		}
		else if (docking_program == "vina")
		{
			idock = false;
		}
		else
		{
			cerr << "Docking program must be either idock or vina\n";
			return 1;
		}

		// Validate docking configuration file.
		if (!exists(docking_config_path))
		{
			cerr << "Docking configuration file " << docking_config_path << " does not exist\n";
			return 1;
		}
		if (!is_regular_file(docking_config_path))
		{
			cerr << "Docking configuration file " << docking_config_path << " is not a regular file\n";
			return 1;
		}

		// Validate output_folder.
		remove_all(output_folder_path);
		if (!create_directories(output_folder_path))
		{
			cerr << "Failed to create output folder " << output_folder_path << '\n';
			return 1;
		}

		// Validate miscellaneous options.
		if (num_threads < 1)
		{
			cerr << "Option threads must be 1 or greater\n";
			return 1;
		}
		if (num_generations < 1)
		{
			cerr << "Option generations must be 1 or greater\n";
			return 1;
		}
		if (num_mutants < 1)
		{
			cerr << "Option mutants must be 1 or greater\n";
			return 1;
		}
		if (num_children < 0)
		{
			cerr << "Option children must be 0 or greater\n";
			return 1;
		}
		if (num_elitists < 0)
		{
			cerr << "Option carryovers must be 0 or greater\n";
			return 1;
		}
		if (max_atoms <= 0)
		{
			cerr << "Option max_atoms must be 1 or greater\n";
			return 1;
		}
	}

	try
	{
		// Initialize the log.
		std::cout << "Logging to " << log_path.string() << '\n';
		igrow::tee log(log_path);

		// Initialize a Mersenne Twister random number generator.
		log << "Using random seed " << seed << '\n';
		mt19937eng eng(seed);

		// Scan the fragment folder to obtain a list of fragments.
		vector<path> fragment_paths;
		fragment_paths.reserve(100);
		{
			using namespace boost::filesystem;
			const directory_iterator end_dir_iter; // A default constructed directory_iterator acts as the end iterator.
			for (directory_iterator dir_iter(fragment_folder_path); dir_iter != end_dir_iter; ++dir_iter)
			{
				// Skip non-regular files such as folders.
				if (!is_regular_file(dir_iter->status())) continue;

				// Save the fragment path.
				fragment_paths.push_back(dir_iter->path());
			}
		}
		const size_t num_fragments = fragment_paths.size();
		log << num_fragments << " fragments found in the fragment folder " << fragment_folder_path.string() << '\n';
		using namespace boost;
		ptr_vector<ligand> fragments(num_fragments);

		// Initialize process context.
		using namespace boost::process;
		context ctx;

		// Initialize arguments to prepare_ligand4.
		vector<string> prepare_ligand4_args(5);
		prepare_ligand4_args[0] = prepare_ligand4_path.string();
		prepare_ligand4_args[1] = "-l";
		prepare_ligand4_args[3] = "-o";

		// Initialize arguments to idock or vina.
		vector<string> docking_args(8);
		docking_args[0] = "--config";
		docking_args[1] = docking_config_path.string();
		docking_args[6] = "--log";
		if (idock)
		{
			docking_args[2] = "--ligand_folder";
			docking_args[4] = "--output_folder";			
		}
		else
		{
			docking_args[2] = "--ligand";
			docking_args[4] = "--out";
		}

		// The number of ligands is equal to the number of elitists plus mutants plus children.
		const size_t population_size = num_elitists + num_mutants + num_children;

		// Initialize csv file for dumping statistics.
		ofile csv(csv_path);

		for (size_t current_generation = 1; current_generation <= num_generations; ++current_generation)
		{
			log << "Running generation " << current_generation << '\n';

			// Initialize the paths to current generation folder and its four subfolders.
			const path current_generation_folder_path(output_folder_path / path(lexical_cast<string > (current_generation)));
			const path current_pdb_folder_path(current_generation_folder_path / path("pdb"));
			const path current_pdbqt_folder_path(current_generation_folder_path / path("pdbqt"));
			const path current_output_folder_path(current_generation_folder_path / path("output"));
			const path current_log_folder_path(current_generation_folder_path / path("log"));

			// Create a new folder and four subfolders for current generation.
			create_directory(current_generation_folder_path);
			create_directory(current_pdb_folder_path);
			create_directory(current_pdbqt_folder_path);
			create_directory(current_output_folder_path);
			create_directory(current_log_folder_path);

			// Generate ligands and save them into the pdb subfolder.
			if (current_generation == 1)
			{
				// Parse and dump the initial ligand.
				ligand initial_lig;
				initial_lig.load(initial_ligand_path);
				initial_lig.save(current_pdb_folder_path / "1.pdb");

				// Create mutants in parallel.
				for (size_t i = 1; i != population_size; ++i)
				{
					ligand lig;
					lig.load(initial_ligand_path);
					//		    string fragment_name = fragments.ReturnRandomFileName();
					//		    lig.mutate(fragments.path + fragment_name);

					if (lig.valid())
					{
						lig.save(current_pdb_folder_path / (lexical_cast<string > (i + 1) + ".pdb"));
					}
				}
			}
			else
			{
				const path previous_generation_folder_path(output_folder_path / path(lexical_cast<string > (current_generation - 1)));
				//	    Interaction interact;
				//	    Ligand child = interact.mate(m1, m2);
				//	    if (child.valid());
			}

			// Convert ligands to PDBQT format by calling prepare_ligand4 python script.
			for (size_t i = 1; i <= population_size; ++i)
			{
				prepare_ligand4_args[2] = (current_pdb_folder_path / path(lexical_cast<string > (i) + ".pdb")).string();
				prepare_ligand4_args[4] = (current_pdbqt_folder_path / path(lexical_cast<string > (i) + ".pdbqt")).string();
				create_child(python_path.string(), prepare_ligand4_args, ctx).wait();
			}

			// Call either idock or vina to dock ligands to predict their free energy and then parse the docking log.
			if (idock)
			{
				// Invoke idock.
				docking_args[3] = current_pdbqt_folder_path.string();
				docking_args[5] = current_output_folder_path.string();
				docking_args[7] = (current_log_folder_path / path("log")).string();
				create_child(docking_program_path.string(), docking_args, ctx).wait();

				// Parse idock log.
				ifile log(current_log_folder_path / path("log"));
				log.seekg(103);
				string line;
				while (getline(log, line))
				{
					if (line[0] == ' ') break; //   index |       ligand |   progress | conf | top 5 conf free energy in kcal/mol
				}
				while (getline(log, line))
				{
					const size_t ligand_id = right_cast<size_t>(line, 11, 22);
					const fl free_energy = right_cast<fl>(line, 46, 51);
				}
				log.close();
			}
			else
			{
				// Invoke vina.
				for (size_t i = 1; i <= population_size; ++i)
				{
					docking_args[3] = (current_pdbqt_folder_path / path(lexical_cast<string > (i) + ".pdbqt")).string();
					docking_args[5] = (current_output_folder_path / path(lexical_cast<string > (i) + ".pdbqt")).string();
					docking_args[7] = (current_log_folder_path / path(lexical_cast<string > (i) + ".log")).string();
					create_child(docking_program_path.string(), docking_args, ctx).wait();
				}

				// Parse vina log.
				for (size_t i = 1; i <= population_size; ++i)
				{
					ifile log(current_log_folder_path / path(lexical_cast<string > (i) + ".log"));
					log.seekg(1177);
					string line;
					while (getline(log, line))
					{
						if (line[3] == '1')
						{
							const size_t start = line.find_first_not_of(' ', 8);
							const fl free_energy = lexical_cast<fl > (line.substr(start, 17 - start));
						}
					}
					log.close();
				}
			}

			// Sort ligands in ascending order of predicted free energy

			// Write csv
		}
	}
	catch (const std::exception& e)
	{
		std::cerr << e.what() << '\n';
		return 1;
	}
}
