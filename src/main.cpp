/*

   Copyright (c) 2011, The Chinese University of Hong Kong

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

*/

#include "common.hpp"
#include "interact.hpp"

#include <boost/lexical_cast.hpp>
#include <boost/random.hpp>
#include <boost/filesystem.hpp>
#include <boost/thread/thread.hpp>
#include <boost/program_options.hpp>
#include <boost/filesystem/operations.hpp>
#include <boost/process.hpp>
#include "seed.hpp"
#include "file.hpp"
#include "tee.hpp"

using namespace std;

// Choose the appropriate Mersenne Twister engine for random number generation on 32-bit or 64-bit platform.
#if defined(__x86_64) || defined(__x86_64__) || defined(__amd64) || defined(__amd64__) || defined(_M_X64) || defined(_M_AMD64)
	typedef boost::random::mt19937_64 mt19937eng;
#else
	typedef boost::random::mt19937 mt19937eng;
#endif

int
main(int argc, char* argv[])
{
    std::cout << "igrow 1.0\n";

    using namespace igrow;
    path fragment_folder_path, initial_ligand_path, python_path, prepare_ligand4_path, vina_cfg_path, output_folder_path, log_path;
    size_t num_threads, seed, num_generations, num_elitists, num_mutants, num_children, max_atoms;

    // Process program options.
    {
	using namespace std;
	using namespace boost::program_options;

	// Initialize the default values of optional arguments.
	const path default_output_folder_path = "output";
	const path default_log_path = "log";
	const unsigned int concurrency = boost::thread::hardware_concurrency();
	const unsigned int default_num_threads = concurrency ? concurrency : 1;
	const size_t default_seed = random_seed();
	const size_t default_num_generations = 8;
	const size_t default_num_mutants = 20;
	const size_t default_num_children = 20;
	const size_t default_num_elitists = 10;
	const size_t default_max_atoms = 80;

	options_description input_options("input (required)");
	input_options.add_options()
		("fragment_folder", value<path > (&fragment_folder_path)->required(), "folder of fragments in PDB format")
		("initial_ligand", value<path > (&initial_ligand_path)->required(), "initial ligand in PDB format")
		("python", value<path > (&python_path)->required(), "python executable")
		("prepare_ligand4", value<path > (&prepare_ligand4_path)->required(), "prepare_ligand4 python script")
		("vina_cfg", value<path > (&vina_cfg_path)->required(), "configuration file for Vina")
		;

	options_description output_options("output (optional)");
	output_options.add_options()
		("output_folder", value<path > (&output_folder_path)->default_value(default_output_folder_path), "folder of output results")
		("log", value<path > (&log_path)->default_value(default_log_path), "log file")
		;

	options_description miscellaneous_options("options (optional)");
	miscellaneous_options.add_options()
		("threads", value<size_t > (&num_threads)->default_value(default_num_threads), "number of worker threads to use")
		("seed", value<size_t > (&seed)->default_value(default_seed), "explicit non-negative random seed")
		("generations", value<size_t > (&num_generations)->default_value(default_num_generations), "number of GA generations")
		("elitists", value<size_t > (&num_elitists)->default_value(default_num_elitists), "number of elite ligands to carry over")
		("mutants", value<size_t > (&num_mutants)->default_value(default_num_mutants), "number of child ligands generated by mutation")
		("children", value<size_t > (&num_children)->default_value(default_num_children), "number of child ligands generated by crossover")		
		("max_atoms", value<size_t > (&max_atoms)->default_value(default_max_atoms), "maximum number of atoms of generated ligands")
		("config", value<path > (), "options can be loaded from a configuration file")
		;

	options_description all_options;
	all_options.add(input_options).add(output_options).add(miscellaneous_options);

	// If no command line argument is supplied, simply print the usage and exit.
	if (argc == 1)
	{
	    cout << all_options;
	    return 0;
	}

	// Parse command line arguments.
	try
	{
	    variables_map vm;
	    store(parse_command_line(argc, argv, all_options), vm);
	    variable_value config_value = vm["config"];
	    if (!config_value.empty()) // If a configuration file is presented, parse it.
	    {
		ifile config_file(config_value.as<path > ());
		store(parse_config_file(config_file, all_options), vm);
	    }
	    vm.notify(); // Notify the user if there are any parsing errors.
	}
	catch (const exception& e)
	{
	    cerr << e.what() << '\n';
	    return 1;
	}

	// Validate fragment folder.
	if (!exists(fragment_folder_path))
	{
	    cerr << "Fragment folder " << fragment_folder_path << " does not exist\n";
	    return 1;
	}
	if (!is_directory(fragment_folder_path))
	{
	    cerr << "Fragment folder " << fragment_folder_path << " is not a directory\n";
	    return 1;
	}

	// Validate initial ligand.
	if (!exists(initial_ligand_path))
	{
	    cerr << "Initial ligand " << initial_ligand_path << " does not exist\n";
	    return 1;
	}
	if (!is_regular_file(initial_ligand_path))
	{
	    cerr << "Initial ligand " << initial_ligand_path << " is not a regular file\n";
	    return 1;
	}

	// Validate python executable.
	if (!exists(python_path))
	{
	    cerr << "Python executable " << python_path << " does not exist\n";
	    return 1;
	}
	if (!is_regular_file(python_path))
	{
	    cerr << "Python executable " << python_path << " is not a regular file\n";
	    return 1;
	}

	// Validate prepare_ligand4 python script.
	if (!exists(prepare_ligand4_path))
	{
	    cerr << "prepare_ligand4 python script " << prepare_ligand4_path << " does not exist\n";
	    return 1;
	}
	if (!is_regular_file(prepare_ligand4_path))
	{
	    cerr << "prepare_ligand4 python script " << prepare_ligand4_path << " is not a regular file\n";
	    return 1;
	}

	// Validate Vina configuration file.
	if (!exists(vina_cfg_path))
	{
	    cerr << "Vina configuration file " << vina_cfg_path << " does not exist\n";
	    return 1;
	}
	if (!is_regular_file(vina_cfg_path))
	{
	    cerr << "Vina configuration file " << vina_cfg_path << " is not a regular file\n";
	    return 1;
	}

	// Validate output_folder.
	remove_all(output_folder_path);
	if (!create_directories(output_folder_path))
	{
	    cerr << "Failed to create output folder " << output_folder_path << '\n';
	    return 1;
	}

	// Validate miscellaneous options.
	if (num_threads < 1)
	{
	    cerr << "Option threads must be 1 or greater\n";
	    return 1;
	}
	if (num_generations < 1)
	{
	    cerr << "Option generations must be 1 or greater\n";
	    return 1;
	}
	if (num_mutants < 1)
	{
	    cerr << "Option mutants must be 1 or greater\n";
	    return 1;
	}
	if (num_children < 0)
	{
	    cerr << "Option children must be 0 or greater\n";
	    return 1;
	}
	if (num_elitists < 0)
	{
	    cerr << "Option carryovers must be 0 or greater\n";
	    return 1;
	}
	if (max_atoms <= 0)
	{
	    cerr << "Option max_atoms must be 1 or greater\n";
	    return 1;
	}
    }

    try
    {
	// Initialize the log.
	std::cout << "Logging to " << log_path.string() << '\n';
	using igrow::tee;
	tee log(log_path);

	// Initialize a Mersenne Twister random number generator.
	log << "Using random seed " << seed << '\n';
	mt19937eng eng(seed);

	// Scan the fragment folder to obtain a list of fragments.
	string fragment_folder = fragment_folder_path.string();

	// The number of ligands is equal to the number of carryovers plus mutants plus children.
	const size_t population_size = num_elitists + num_mutants + num_children;
	using namespace boost;
	// Initialize generation 1.
	{
	    log << "Creating initial population of " << population_size << " ligands by mutation\n";

	    // Create a folder for generation 1.
	    path generation_folder_path(output_folder_path / path("1"));
	    create_directory(generation_folder_path);

	    // Parse and dump the initial ligand.
	    Ligand initial_lig;
	    initial_lig.LoadPDB(initial_ligand_path.string());
	    initial_lig.SavePDB((generation_folder_path / "ligand1.pdb").string());

	    // Create mutants in parallel.
	    for (size_t i = 1; i != population_size; ++i)
	    {
		for (size_t num_trials = 0; true;)
		{
		    Ligand lig;
		    lig.LoadPDB(initial_ligand_path.string());
//		    string fragment_name = fragments.ReturnRandomFileName();
//		    lig.mutate(fragments.path + fragment_name);

		    if (lig.valid())
		    {
//			lig.comments.push_back(string("Mutation,0,") + initial_ligand_path.stem().string() + ",0," + fragment_name);
			lig.SavePDB((generation_folder_path / ("ligand" + lexical_cast<string > (i + 1) + ".pdb")).string());
			break;
		    }

		    if (++num_trials == 1000)
		    {
			log << "ERROR: There is no possible formation for this ligand, exiting";
			return -1;
		    }
		}
	    }
	}

	// Initialize process context and arguments to prepare_ligand4 and Vina.
	using namespace boost::process;
	context ctx;
	vector<string> prepare_ligand4_args(3);
	prepare_ligand4_args[0] = prepare_ligand4_path.string();
	prepare_ligand4_args[1] = "-l";
	vector<string> vina_args(6);
	vina_args[0] = "--config";
	vina_args[1] = vina_cfg_path.string();
	vina_args[2] = "--ligand";
	vina_args[4] = "--log";
	
	string output_folder = output_folder_path.string() + "/";
	Interaction interact;
	for (size_t current_generation = 1; current_generation <= num_generations; ++current_generation)
	{
	    const path current_generation_folder_path(output_folder_path / path(lexical_cast<string > (current_generation)));
	    ctx.work_dir = current_generation_folder_path.string();

	    log << "Converting ligands to PDBQT format\n";
	    for (size_t i = 1; i <= population_size; ++i)
	    {
		prepare_ligand4_args[2] = "ligand" + lexical_cast<string>(i) + ".pdb";
		create_child(python_path.string(), prepare_ligand4_args, ctx).wait();
	    }
	    
	    log << "Docking ligands\n";
	    for (size_t i = 1; i <= population_size; ++i)
	    {
		vina_args[3] = "ligand" + lexical_cast<string>(i) + ".pdbqt";
		vina_args[5] = "ligand" + lexical_cast<string>(i) + ".txt";
		create_child(find_executable_in_path("vina"), vina_args, ctx).wait();
	    }
	    
//	    Ligand* child = interact.mate(m1, m2);
//	    if (child->valid());
	}

	return 0;
    }
    catch (const std::exception& e)
    {
	std::cerr << e.what() << '\n';
	return 1;
    }
}
